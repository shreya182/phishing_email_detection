/**
 * Copyright (C) 2021 Marvin Schopf
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @license Apache-2.0
 * @copyright 2021 Marvin Schopf
 * @author Marvin Schopf <marvin@schopf.biz>
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import fetch from "node-fetch";
function asyncForEach(array, callback) {
    return __awaiter(this, void 0, void 0, function* () {
        for (let index = 0; index < array.length; index++) {
            yield callback(array[index], index, array);
        }
    });
}
export class GoogleSafeBrowsingClient {
    constructor(apiKey) {
        this.apiKey = apiKey;
    }
    lookupUrl(domains, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let _domains = [];
            if (typeof domains === "string") {
                _domains[0] = { url: domains };
            }
            else {
                yield asyncForEach(domains, (domain) => {
                    _domains.push({
                        url: domain,
                    });
                });
            }
            let threatTypes = [
                "THREAT_TYPE_UNSPECIFIED",
                "MALWARE",
                "POTENTIALLY_HARMFUL_APPLICATION",
                "SOCIAL_ENGINEERING",
                "UNWANTED_SOFTWARE",
            ];
            if (options && options.threatTypes) {
                threatTypes = options.threatTypes;
            }
            let requestBody = JSON.stringify({
                client: this._getClientInfo(),
                threatInfo: {
                    threatEntryTypes: ["URL"],
                    platformTypes: ["ANY_PLATFORM"],
                    threatTypes: threatTypes,
                    threatEntries: _domains,
                },
            });
            const response = yield fetch(`https://safebrowsing.googleapis.com/v4/threatMatches:find?key=${this.apiKey}`, {
                method: "POST",
                headers: {
                    "Content-type": "application/json",
                },
                body: requestBody,
            });
            if (response.status === 200) {
                const responseJson = yield response.json();
                if (responseJson.matches) {
                    const matches = responseJson.matches;
                    return matches;
                }
                else {
                    return [];
                }
            }
            else
                throw new Error(`Google Safe Browsing: ${response.status}: ${yield response.text()}`);
        });
    }
    isUrlSafe(url) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.lookupUrl(url)).length === 0;
        });
    }
    _getClientInfo() {
        return {
            clientId: "marvinschopf/google-safe-browsing",
            clientVersion: "1.0.0",
        };
    }
}
export default GoogleSafeBrowsingClient;
